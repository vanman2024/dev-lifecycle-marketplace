# Build Command Reference

**Project**: {{PROJECT_NAME}}
**Generated**: {{TIMESTAMP}}
**Source**: Architecture detected from `{{ARCHITECTURE_DOCS_PATH}}`

## Tech Stack

{{TECH_STACK_LIST}}

**Marketplaces Indexed**:
- dev-lifecycle-marketplace
- ai-dev-marketplace
- mcp-servers-marketplace

---

## Build Layers

Execute commands in layer order for systematic project build.

### Layer 1: Infrastructure Foundation

**Purpose**: Core project setup - detection, specs, worktrees
**Execution**: Sequential (each command depends on previous)
**Estimated Time**: 5-10 minutes

**Commands**:
```bash
# Detect tech stack from codebase
/foundation:detect

# Generate comprehensive specs via multimodal wizard
/planning:wizard

# Design system architecture with diagrams
/planning:architecture

# Setup git worktrees for parallel agent execution
/supervisor:init --all
```

**Plugins Used**: `foundation`, `planning`, `supervisor`

---

### Layer 2: Tech Stack Initialization

**Purpose**: Initialize detected frameworks and services
**Execution**: Parallel (independent setups)
**Estimated Time**: 10-15 minutes

**Commands**:
{{LAYER_2_COMMANDS_FORMATTED}}

**Plugins Used**: {{LAYER_2_PLUGINS_LIST}}

{{LAYER_2_GAPS_WARNING}}

---

### Layer 3: Feature Implementation

**Purpose**: Build features from specs using detected tech stack
**Execution**: Spec-driven (reference spec files)
**Estimated Time**: Variable

**Available Commands by Category**:

{{LAYER_3_COMMANDS_BY_CATEGORY}}

**Plugins Used**: {{LAYER_3_PLUGINS_LIST}}

**Notes**:
- Commands used depend on spec requirements
- Reference this BUILD-GUIDE when Claude implements features
- Use `/planning:spec list` to see all spec files

---

### Layer 4: Quality & Deployment

**Purpose**: Testing, validation, and production deployment
**Execution**: Sequential (test before deploy)
**Estimated Time**: 15-20 minutes

**Commands**:
```bash
# Run comprehensive test suite (Newman API, Playwright E2E, security)
/quality:test

# Auto-detect platform and deploy with validation
/deployment:deploy

# Semantic versioning with changelog generation
/versioning:bump patch
```

**Plugins Used**: `quality`, `deployment`, `versioning`

---

## Gap Detection

{{GAPS_SECTION}}

---

## Summary

**Total Commands Available**: {{TOTAL_COMMAND_COUNT}}
**Total Plugins Indexed**: {{TOTAL_PLUGIN_COUNT}}
**Missing Plugins**: {{MISSING_PLUGIN_COUNT}}

**Airtable Base**: appHbSB7WhT1TxEQb
**Generated By**: build-manifest-generator agent

---

## Usage

When implementing features, Claude references this guide to:
1. Identify available commands for the tech stack
2. Know which plugins handle which technologies
3. Follow the layered execution pattern
4. Detect missing plugins before starting work

**Example**:
```
User: "Add authentication with Supabase"
Claude: *Reads BUILD-GUIDE.json*
Claude: "I see /supabase:add-auth is available in Layer 2. Let me use that..."
```

**Regenerate**:
```bash
/planning:generate-build-guide --refresh
```
